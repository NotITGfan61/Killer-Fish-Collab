<Plugin OnCommand = "%xero(function(self)
	
	SineS, CubicS, QuintS, CircS, ElasticS, QuadS, QuartS, ExpoS, BackS, BounceS,
	SineO, CubicO, QuintO, CircO, ElasticO, QuadO, QuartO, ExpoO, BackO, BounceO,
	SineI, CubicI, QuintI, CircI, ElasticI, QuadI, QuartI, ExpoI, BackI, BounceI  
	= inOutSine, inOutCubic, inOutQuint, inOutCirc, inOutElastic, inOutQuad, inOutQuart, inOutExpo, inOutBack, inOutBounce,
	outSine, outCubic, outQuint, outCirc, outElastic, outQuad, outQuart, outExpo, outBack, outBounce,
	inSine, inCubic, inQuint, inCirc, inElastic, inQuad, inQuart, inExpo, inBack, inBounce
	
	SmoothS = inOutElastic:param(1,2)
	SmoothO = outElastic:param(1,2)
	SmoothI = inElastic:param(1,2)
	
	WiggleS = inOutElastic:param(1,0.5)
	WiggleO = outElastic:param(1,0.5)
	WiggleI = inElastic:param(1,0.5)
	
	function modulo(a, b)
		return a - math.floor(a/b)*b;
	end
	
	--mix ease
	function mixEase(e1, e2, point)
		if not point then point = 0.5 end

		return function(a)
			if a < point then
				return e1(a / point) * point
			else
				return e2((a - point) / (1 - point)) * (1 - point) + point
			end
		end
	end
	
	function ease2(t)
    	t[1] = t[1] - (t[2]*0.5)
    	return ease(t)
    end
	
	function add2(t)
    	t[1] = t[1] - (t[2]*0.5)
    	return add(t)
    end
	
	--smooth ease
	function ease_smooth(beat,len,amount,mod,inEase,outEase,point,pn)
		ease {beat-(len*point),len, mixEase(xero['in'..inEase],xero['out'..outEase],point), amount, mod, plr = pn}
	end
	
	--smooth add
	function add_smooth(beat,len,amount,mod,inEase,outEase,point,pn)
		add {beat-(len*point),len, mixEase(xero['in'..inEase],xero['out'..outEase],point), amount, mod, plr = pn}
	end
	
	--mod bounce
	function mod_bounce(beat,length,start,apex,mod,outEase,inEase,pn)
		len = length/2
		ease{beat,len,outEase,apex,mod,plr=pn}
		ease{beat+len,len,inEase,start,mod,plr=pn}
	end
	
	function kick(Beat,inLen,outLen,inEase,outEase,Start,Apex,mod,pn)
		set{Beat-inLen,Start,mod,plr=pn}
		ease{Beat-inLen,inLen,xero['in'..inEase],Apex,mod,plr=pn}
		ease{Beat,outLen,xero['out'..outEase],Start,mod,plr=pn}
	end
	
	--wiggles
	function wiggle(beat, length, step, ease_func, percent, mod, plr)
		if length > step then
			local val = -1
			for i = beat, beat + length - step, step do
				if i == beat then
					add {i, step, ease_func, percent, mod, plr = plr}
				elseif i > beat + length - 2 * step then
					add {i, step, ease_func, percent * val, mod, plr = plr}
				else
					add {i, step, ease_func, percent * 2 * val, mod, plr = plr}
					val = -val
				end
			end
		end
	end
	
	--drivendrop
	function drivendrop(beat, length, step, speedmod, plr)
		for i = beat, beat + length - step, step do
			add
			{i, step, linear, speedmod * step * 100, 'centered2', plr = plr}
			{i + step, 0, instant, -speedmod * step * 100, 'centered2', plr = plr}
		end
	end
	
	function drivendrop2(beat, length, step, speedmod,resetspeed,resetease, plr)
			add
			{i, step, linear, speedmod * step * 100, 'centered2', plr = plr}
			{i + step, resetspeed, resetease, -speedmod * step * 100, 'centered2', plr = plr}
	end
	
	--sugarkiller
	function sugarkiller(beat, length, step, minstealth, maxstealth, plr)
		if not minstealth then minstealth = 50 end;
		if not maxstealth then maxstealth = 85 end;
		if not step then step = 1 end;
		if not length then length = 1 end;
		for i = 0, math.max(length-1,0) do
			ease
			{beat+(i*0.5), .25/step, instant, 100, 'invert', 0, 'flip', maxstealth, 'stealth', plr = plr}
			{beat+(i*0.5)+.25/step, .25/step, instant, 100, 'flip', 0, 'invert', maxstealth, 'stealth', plr = plr}
			{beat+(i*0.5)+.50/step, .25/step, instant, 100, 'flip', -100, 'invert', maxstealth, 'stealth', plr = plr}
			if i == math.max(length-1,0) then
				ease
				{beat+(i*0.5)+.75/step, .25/step, instant, 0, 'flip', 0, 'invert', 0, 'stealth', plr = plr}
			else
				ease
				{beat+(i*0.5)+.75/step, .25/step, instant, 0, 'flip', 0, 'invert', minstealth, 'stealth', plr = plr}
			end
		end
	end
	
	
	--beat mods
	function BeatX(beat,strength,pn)
	if not strength then strength = 1000 end;
		set {beat-.5, strength, 'beat', plr = pn}
		set {beat+.5, 0, 'beat', plr = pn}
	end
	
	function BeatY(beat,strength,pn)
	if not strength then strength = 1000 end;
		set {beat-.5, strength, 'beaty', plr = pn}
		set {beat+.5, 0, 'beaty', plr = pn}
	end
	
	
	function BeatZ(beat,strength,pn)
	if not strength then strength = 1000 end;
		set {beat-.5, strength, 'beatz', plr = pn}
		set {beat+.5, 0, 'beatz', plr = pn}
	end
	
	
	
	
	function centered2scroll(beat,resetbeat,len,eas,amt,plr)
		ease {beat, len, eas, amt * 100, 'centered2', plr = pn}
		ease {beat, len, eas, -amt * 100, 'movey', plr = pn}
		
		ease {resetbeat, 1, instant, 0, 'centered2', plr = pn}
		ease {resetbeat, 1, instant, 0, 'movey', plr = pn}
	end
	
	
	function textureSet(texturename,size1,size2,xvelocity,yvelocity)
		texturename:customtexturerect(0,0,size1,size2)
		texturename:texcoordvelocity(xvelocity,yvelocity)
	end
	
	function shader(spritename,aftname)
		spritename:SetTexture(aftname:GetTexture())
	end
	
	function shadermod(shadername,modname,uniform)
		definemod {modname, function(percent)
			shadername:GetShader():uniform1f(uniform,percent)
		end}
	end
	
	function centerPlr(beat)
		func{beat,function()
			for pn = 1,2 do
				P[pn]:x(SCREEN_CENTER_X)
			end
		end}
	end
	
	function uncenterPlr(beat)
		func{beat,function()
			P1:x(SCREEN_CENTER_X - (sw / 4))
			P2:x(SCREEN_CENTER_X + (sw / 4))
		end}
	end
	
	function imageSetup(imagename)
		imagename:xywh(scx,scy,sw,sh)
	end
	
	
	
	
	function shake(beat,len,percent,mod,pn)
		ease{beat,len,popElastic.params(1,25),percent,mod, plr = pn}
	end
	
	function drivencalc(speed,step)
		return speed * step * 100
	end
	
	------------------------------------------------ definemod stuff -------------------------------------------------------
	--blacksphere
	definemod {'blacksphere',function(blacksphere)
        local invert = 50 - 50 * math.cos(blacksphere * math.pi / 180)
        local alternate = 25 * math.sin(blacksphere * math.pi / 180)
        local reverse = -12.5 * math.sin(blacksphere * math.pi / 180)
        return invert, alternate, reverse
    end,
    'invert', 'alternate', 'reverse',
	}
	
	--counterrotation mod (thanks mang)
	definemod{'coolrotationx','coolrotationy','coolrotationz',function(xDegrees, yDegrees, zDegrees, plr)
		local function mindf_reverseRotation(angleX, angleY, angleZ)
			local sinX = math.sin(angleX);
			local cosX = math.cos(angleX);
			local sinY = math.sin(angleY);
			local cosY = math.cos(angleY);
			local sinZ = math.sin(angleZ);
			local cosZ = math.cos(angleZ);
			return { math.atan2(-cosX*sinY*sinZ-sinX*cosZ,cosX*cosY),
					math.asin(-cosX*sinY*cosZ+sinX*sinZ),
					math.atan2(-sinX*sinY*cosZ-cosX*sinZ,cosY*cosZ) }
		end
		local DEG_TO_RAD = math.pi / 180
		local angles = mindf_reverseRotation(xDegrees * DEG_TO_RAD, yDegrees * DEG_TO_RAD, zDegrees * DEG_TO_RAD)
		local rotationx,rotationy,rotationz=
			xDegrees,
			yDegrees,
			zDegrees
		local confusionxoffset,confusionyoffset,confusionzoffset=
			(angles[1]*100),
			(angles[2]*100),
			(angles[3]*100)
	
		return rotationx,rotationy,rotationz,confusionxoffset,confusionyoffset,confusionzoffset
	end,
	'rotationx','rotationy','rotationz','confusionxoffset','confusionyoffset','confusionzoffset'
	}

	--XeroOl's column specific rotation mods 
	for col = 0, 3 do
		definemod {'rotationz'..col,
			function(p)
			if p % 360 == 0 then return 0, 0, 0, 0 end
			if p % 180 == 0 then return 100, 0, 0, 0 end
			local theta = p * math.pi / 180
			return 50 - 50 * math.cos(theta), 900, -212.5, 1000 * math.sin(theta)
			end,
		'reverse'..col, 'zigzagperiod'..col, 'zigzagoffset'..col, 'zigzag'..col}
	end
	for col = 0, 3 do
		definemod {'rotationx'..col,
			function(p)
			if p % 360 == 0 then return 0, 0, 0, 0 end
			if p % 180 == 0 then return 100, 0, 0, 0 end
			local theta = p * math.pi / 180
			return 50 - 50 * math.cos(theta), 900, -212.5, 1000 * math.sin(theta)
			end,
		'reverse'..col, 'zigzagzperiod'..col, 'zigzagzoffset'..col, 'zigzagz'..col}
	end
	
	
	definemod{'walk', function(amt)
    amt = amt * 0.01
		local invert = -(math.cos((amt*100)*math.pi)*50)+50
		local alternate = (math.sin((amt*100)*math.pi)*25)*1
		local reverse = (math.sin((amt*100)*math.pi)*25/2)*-1
		local movey = math.abs(math.sin((amt*100)*math.pi)*50)*-1
			return invert, alternate, reverse, movey
	end, 'invert', 'alternate', 'reverse', 'movey'}
	
	definemod {'coolreverse', function(r)
			return r,r,r,r
		end,
		'reverse0','reverse1','reverse2','reverse3'
	}
	
	definemod {'coolskewx', function(p)
			return p,-p
		end,
		'skewx','noteskewx'
	}
	
	definemod {'coolskewy', function(p)
			return p,-p
		end,
		'skewy','noteskewy'
	}
	
	definemod {'pieces', function(p)
			return p,p,-p/4
		end,
		'hidden','brake','hiddenoffset'
	}
	
	definemod {'cooltiny', function(r)
			return r,r,r,r
		end,
		'tiny0','tiny1','tiny2','tiny3'
	}
	
	definemod {'cooltiny2', function(r)
			return r,r,r
		end,
		'tinyx','tinyy','tinyz'
	}
	
	definemod {'cooldrunk', function(r)
			return r,r,r,r
		end,
		'drunk0','drunk1','drunk2','drunk3'
	}
	
	definemod {'cooldrunkspeed', function(r)
			return r,r,r,r
		end,
		'drunkspeed0','drunkspeed1','drunkspeed2','drunkspeed3'
	}
	
	definemod {'cooldrunkspacing', function(r)
			return r,r,r,r
		end,
		'drunkspacing0','drunkspacing1','drunkspacing2','drunkspacing3'
	}
	
	definemod {'blackspherez', 
	function(a) 
		local invert = 50 - 50 * math.cos(a * math.pi / 180)
		   -- local alternate = 25 * math.sin(a * math.pi / 180)

		   local mz1 = 50 * math.sin(a * math.pi / 180)
		   local mz2 = -50 * math.sin(a * math.pi / 180)

		   return invert, mz1,mz2,mz2,mz1
	end,
	'invert', 'movez0', 'movez1', 'movez2', 'movez3'}
	
	definemod {
    'arrowfade',
    function(percent,pn)
	
	for col = 0,3 do
		P[pn]:SetNumArrowGradientPoints(col,4)	-- for each column, set the number of points to 4
		
		P[pn]:SetArrowGradientPoint(0,col,1) -- set their points
		P[pn]:SetArrowGradientPoint(3,col,4)
		
		P[pn]:SetArrowGradientColor(0,col,1,1,1,1-(percent/100))	-- set their colors and shiet
		P[pn]:SetArrowGradientColor(3,col,1,1,1,1-(percent/100))
	end
	
        local dark = percent / 2 + 50
        return dark
    end,
    'dark',
	}
	
	definemod {'confx','confy','confz',function(xd, yd, zd)
			return 100*math.rad(xd), 100*math.rad(yd), 100*math.rad(zd)
		end,
		'confusionxoffset','confusionyoffset','confusionoffset'
	}
	definemod {'conf',function(zd)
			return 100*math.rad(zd)
		end,
		'confusionoffset'
	}
	
	function transparentaft(self)
		self:SetWidth(dw)
		self:SetHeight(dh)
		self:EnableDepthBuffer(false)
		self:EnableAlphaBuffer(true)
		self:EnableFloat(false)
		self:EnablePreserveTexture(true)
		self:Create()
	end

	function modelzoom(name,p)
		name:zoomx(p):zoomy(p):zoomz(p)
	end
	
	function RealFov(fov)
		return 360 / math.pi * math.atan(math.tan(math.pi * fov / 360) * DISPLAY:GetDisplayWidth() / DISPLAY:GetDisplayHeight() * 0.75)
	end
	
	function AfSetup(Name,FovAmt)
		Name:xy(scx,scy)
		Name:fov(RealFov(FovAmt))
		Name:SetFarDist(9e9)
	end
	
	function ModelSetup(Name,Zoom)
		modelzoom(Name,Zoom)
	end
	
	function rgb(name,r,g,b,a)
		name:diffuse(r/255,g/255,b/255,a)
	end
	
end)" />